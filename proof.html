<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sideways Pyramid Flex Layout</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .container {
      display: flex;
      height: 100%;
      width: 100%;
    }

    .col1,
    .col2,
    .col3 {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .col1 {
      flex: 0 0 45%;
    }

    .col2 {
      flex: 0 0 45%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
    }

    .col3 {
      flex: 0 0 10%;
    }

    /* Column 1 Rows */
    .col1 .row {
      flex: 1;
      border: 1px solid #aaa;
    }

    /* Column 2 Inner Columns */
    .col2 .inner-column {
      display: flex;
      flex-direction: column;
      justify-content: center;
      flex: 1;
      margin: 0 10px;
    }

    .col2 .inner-column .row {
      border: 1px solid #88a;
      margin-bottom: 10px;
      flex: 1;
    }

    .col2 .inner-column .row:last-child {
      margin-bottom: 0;
    }

    /* Adjusted heights for pyramid effect */
    .col2 .inner-column:nth-child(1) {
      height: 100%;
    }

    .col2 .inner-column:nth-child(2) {
      height: 90%;
    }

    .col2 .inner-column:nth-child(3) {
      height: 70%;
    }

    .col2 .inner-column:nth-child(4) {
      height: 50%;
    }

    /* Column 3 Rows */
    .col3 .top,
    .col3 .bottom {
      flex: 1;
      border: 1px solid #a88;
    }

    .col3 .middle {
      flex: 0 0 20%;
      border: 1px solid #a88;
      display: flex;
      align-items: center;
      justify-content: center;
    }



    .form-container {
      display: flex;
      flex-direction: column;
      width: 90%;
      margin-top: 20px;
    }

    .form-row {
      display: flex;
      margin-bottom: 5px;
    }

    .form-row label {
      flex: 1;
      text-align: right;
      padding-right: 10px;
    }

    .form-row input,
    .form-row textarea {
      flex: 6;
    }


    .checkbox-row {
      display: flex;
      align-items: center;
      /* Align checkbox and label vertically */
    }

    .checkbox-row label {
      flex: 1;
      text-align: right;
      /* Align label text to right like other labels */
      padding-right: 10px;
      /* Match padding of other labels */
    }

    .checkbox-row input[type="checkbox"] {
      flex: 1;
      /* Match the flex value of other inputs */
      width: auto;
      /* Let the checkbox determine its own width */
      margin-right: 0;
      /* Remove any default margins */
      text-align: left;
    }

    .checkbox-row div {
      flex: 5;
    }

    .content {
      padding: 10px;
      margin: 10px;
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- BALANCE -->
    <div class="col1">
      <div class="row">
        <form class="form-container">
          <div class="form-row">
            <label for="balance">Balance:</label>
            <input type="number" id="balance" name="balance">
          </div>
          <div class="form-row">
            <label for="balance-hash">Hash:</label>
            <input type="text" id="balance-hash" name="balance-hash" readonly>
          </div>
          <div class="form-row checkbox-row">
            <label for="hide-balance">Hide:</label>
            <input type="checkbox" id="hide-balance" name="hide-balance">
            <div></div>
          </div>
        </form>
      </div>
      <!-- AMOUNT -->
      <div class="row">

        <form class="form-container">
          <div class="form-row">
            <label for="amount">Amount:</label>
            <input type="number" id="amount" name="amount">
          </div>
          <div class="form-row">
            <label for="amount-hash">Hash:</label>
            <input type="text" id="amount-hash" name="amount-hash" readonly>
          </div>
          <div class="form-row checkbox-row">
            <label for="hide-amount">Hide:</label>
            <input type="checkbox" id="hide-amount" name="hide-amount">
            <div></div>
          </div>
        </form>
      </div>
      <!-- PROOF -->
      <div class="row">
        <div class="content">
          <div>Proof:</div>
          <textarea cols="80" rows="4" id="proof" name="proof"></textarea>
        </div>
      </div>
      <!-- RESULT -->
      <div class="row">
        <div class="content">
          <div>Result:</div>
          <div id="result" style="font-size: 1.5em; border: 1px solid #aaa; padding: 10px;"></div>
        </div>
      </div>
      <!-- NONCE -->
      <div class="row">
        <div class="content">
          <div>Nonce:</div>
          <textarea cols="80" rows="2" id="nonce" name="nonce"></textarea>
        </div>
      </div>
    </div>

    <!-- Second Column (Sideways Pyramid) -->
    <div class="col2">
      <div class="inner-column">
        <div class="row">1.1</div>
        <div class="row">1.2</div>
        <div class="row">1.3</div>
        <div class="row">1.4</div>
        <div class="row">1.5</div>
      </div>
      <div class="inner-column">
        <div class="row">2.1</div>
        <div class="row">2.2</div>
        <div class="row">2.3</div>
        <div class="row">2.4</div>
      </div>
      <div class="inner-column">
        <div class="row">3.1</div>
        <div class="row">3.2</div>
        <div class="row">3.3</div>
      </div>
      <div class="inner-column">
        <div class="row">4.1</div>
        <div class="row">4.2</div>
      </div>
    </div>

    <!-- Third Column -->
    <div class="col3">
      <div class="top">Top</div>
      <div class="middle">Middle</div>
      <div class="bottom">Bottom</div>
    </div>
  </div>




  <script>
    function hashToHexColor(hash, minBrightness = 0.3, maxBrightness = 0.8) {
      if (!/^[0-9a-f]+$/i.test(hash)) {
        throw new Error('Input must be a hexadecimal string');
      }

      let hexColor;
      let isValid = false;
      let attempts = 0;
      const maxAttempts = 10;

      // Try to find a color within brightness range
      while (!isValid && attempts < maxAttempts) {
        // Take different 6-character segments with each attempt
        const startPos = attempts * 6 % (hash.length - 6);
        hexColor = hash.substring(startPos, startPos + 6).padEnd(6, '0');

        // Convert to RGB to check brightness
        const r = parseInt(hexColor.substring(0, 2), 16) / 255;
        const g = parseInt(hexColor.substring(2, 4), 16) / 255;
        const b = parseInt(hexColor.substring(4, 6), 16) / 255;

        // Calculate perceived brightness
        const brightness = 0.299 * r + 0.587 * g + 0.114 * b;

        if (brightness >= minBrightness && brightness <= maxBrightness) {
          isValid = true;
        }

        attempts++;
      }

      return `#${hexColor}`;
    }


    /**
     * INPUTS
    */

    const hideBalanceCheckbox = document.getElementById('hide-balance');
    const balanceInput = document.getElementById('balance');
    const balanceHashInput = document.getElementById('balance-hash');
    const hideAmountCheckbox = document.getElementById('hide-amount');
    const amountInput = document.getElementById('amount');
    const amountHashInput = document.getElementById('amount-hash');
    const proofTextarea = document.getElementById('proof');
    const resultsDiv = document.getElementById('result');

    hideBalanceCheckbox.addEventListener('change', function () {
      balanceInput.type = this.checked ? 'password' : 'number';
    });

    hideAmountCheckbox.addEventListener('change', function () {
      amountInput.type = this.checked ? 'password' : 'number';
    });




    function executeWithTimeout(code, variables = {}, timeout = 1000) {
      return new Promise((resolve, reject) => {
        const workerCode = `
      self.onmessage = function(e) {
        const { code, variables } = e.data;
        try {
          // Create function with injected variables
          const fn = new Function(
            ...Object.keys(variables),
            \`
              try {
                \${code}
              } catch(err) {
                return { __error: err.message };
              }
            \`
          );
          
          // Execute with variables as arguments
          const result = fn(...Object.values(variables));
          
          postMessage({
            result: result?.__error ? { error: result.__error } : { data: result }
          });
        } catch (err) {
          postMessage({ error: err.message });
        }
      };
    `;

        const worker = new Worker(URL.createObjectURL(
          new Blob([workerCode], { type: 'application/javascript' })
        ));

        worker.onmessage = (e) => {
          if (e.data.error) {
            reject(new Error(e.data.error));
          } else if (e.data.result?.error) {
            reject(new Error(e.data.result.error));
          } else {
            resolve(e.data.result?.data);
          }
          worker.terminate();
        };

        worker.postMessage({ code, variables });

        setTimeout(() => {
          worker.terminate();
          reject(new Error('Execution timed out after ' + timeout + 'ms'));
        }, timeout);
      });
    }

    // Main execution function
    async function executeProofCode() {

      try {
        resultsDiv.textContent = 'Executing...';

        const variables = {
          balance: Number(balanceInput.value),
          amount: Number(amountInput.value)
        };

        const result = await executeWithTimeout(
          proofTextarea.value,
          variables,
          2000 // 2 second timeout
        );

        resultsDiv.innerHTML = `
      <strong>Result:</strong> ${JSON.stringify(result, null, 2)}<br>
      <strong>Variables:</strong> ${JSON.stringify(variables, null, 2)}
    `;

      } catch (error) {
        resultsDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
        console.error('Execution error:', error);
      }
    }




    proofTextarea.addEventListener('input', executeProofCode);

    // Function to generate SHA-256 hash
    async function generateSHA256Hash(message) {
      // Encode the message as UTF-8
      const msgBuffer = new TextEncoder().encode(message);

      // Hash the message
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);

      // Convert ArrayBuffer to hex string
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

      return hashHex;
    }


    // Add event listener for input changes
    balanceInput.addEventListener('input', async function () {
      const balanceValue = balanceInput.value;

      if (balanceValue) {
        try {
          const hash = await generateSHA256Hash(balanceValue);
          balanceHashInput.value = hash;
        } catch (error) {
          console.error('Error generating hash:', error);
          balanceHashInput.value = 'Error generating hash';
        }
      } else {
        balanceHashInput.value = '';
      }
    });


    amountInput.addEventListener('input', async function () {
      const amountValue = amountInput.value;

      if (amountValue) {
        try {
          const hash = await generateSHA256Hash(amountValue);
          amountHashInput.value = hash;
        } catch (error) {
          console.error('Error generating hash:', error);
          amountHashInput.value = 'Error generating hash';
        }
      } else {
        amountHashInput.value = '';
      }
    });
  </script>
</body>

</html>